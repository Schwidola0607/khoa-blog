<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Sequence Parallelism for Inference: Part 1 | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Introduction
Nd&#43; parallelism techniques are often invented for training first, then adapted for inference. Most techniques have seen great success in today&rsquo;s inference world (both individually and together). However, Sequence Parallelism has not seen wide adoption in the open source world. If you look at vLLM or SGLang today, sequence parallelism is either in not-so-active development or completely deprioritized.
As a huge fan of low time-to-first-token (TTFT) long-sequence inference (motivated by my work at Augment Code‚Äîcheck us out!), this greatly saddens me. This blog series aims to bring back some love for Sequence Parallelism for Inference.">
    <meta name="generator" content="Hugo 0.153.2">
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css" >




    


    
      

    

    

    
      <link rel="canonical" href="https://example.org/posts/sequence_parallelism_for_inference_part_1/">
    

    
    
    <meta property="og:url" content="https://example.org/posts/sequence_parallelism_for_inference_part_1/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Sequence Parallelism for Inference: Part 1">
  <meta property="og:description" content="Introduction Nd&#43; parallelism techniques are often invented for training first, then adapted for inference. Most techniques have seen great success in today‚Äôs inference world (both individually and together). However, Sequence Parallelism has not seen wide adoption in the open source world. If you look at vLLM or SGLang today, sequence parallelism is either in not-so-active development or completely deprioritized. As a huge fan of low time-to-first-token (TTFT) long-sequence inference (motivated by my work at Augment Code‚Äîcheck us out!), this greatly saddens me. This blog series aims to bring back some love for Sequence Parallelism for Inference.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-23T21:35:22+00:00">
    <meta property="article:modified_time" content="2025-12-23T21:35:22+00:00">

  <meta itemprop="name" content="Sequence Parallelism for Inference: Part 1">
  <meta itemprop="description" content="Introduction Nd&#43; parallelism techniques are often invented for training first, then adapted for inference. Most techniques have seen great success in today‚Äôs inference world (both individually and together). However, Sequence Parallelism has not seen wide adoption in the open source world. If you look at vLLM or SGLang today, sequence parallelism is either in not-so-active development or completely deprioritized. As a huge fan of low time-to-first-token (TTFT) long-sequence inference (motivated by my work at Augment Code‚Äîcheck us out!), this greatly saddens me. This blog series aims to bring back some love for Sequence Parallelism for Inference.">
  <meta itemprop="datePublished" content="2025-12-23T21:35:22+00:00">
  <meta itemprop="dateModified" content="2025-12-23T21:35:22+00:00">
  <meta itemprop="wordCount" content="1464">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Sequence Parallelism for Inference: Part 1">
  <meta name="twitter:description" content="Introduction Nd&#43; parallelism techniques are often invented for training first, then adapted for inference. Most techniques have seen great success in today‚Äôs inference world (both individually and together). However, Sequence Parallelism has not seen wide adoption in the open source world. If you look at vLLM or SGLang today, sequence parallelism is either in not-so-active development or completely deprioritized. As a huge fan of low time-to-first-token (TTFT) long-sequence inference (motivated by my work at Augment Code‚Äîcheck us out!), this greatly saddens me. This blog series aims to bring back some love for Sequence Parallelism for Inference.">

      
      
    
	
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css"
  integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi"
  crossorigin="anonymous"
>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js"
  integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ"
  crossorigin="anonymous">
</script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
  crossorigin="anonymous"
  onload="renderMathInElement(document.body);">
</script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '\\[', right: '\\]', display: true},   
        {left: '$$', right: '$$', display: true},     
        {left: '\\(', right: '\\)', display: false},  
        {left: '$', right: '$', display: false},      
      ],
      throwOnError : false
    });
  });
</script>





  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Sequence Parallelism for Inference: Part 1</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2025-12-23T21:35:22Z">December 23, 2025</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><h1 id="introduction">Introduction</h1>
<p><a href="https://blog.ezyang.com/2025/08/the-parallelism-mesh-zoo/">Nd+ parallelism techniques</a> are often invented for training first, then adapted for inference. Most techniques have seen great success in today&rsquo;s inference world (both individually and together). However, Sequence Parallelism has not seen wide adoption in the open source world. If you look at vLLM or SGLang today, sequence parallelism is either in not-so-active development or completely deprioritized.
As a huge fan of low time-to-first-token (TTFT) long-sequence inference (motivated by my work at <a href="https://www.augmentcode.com/">Augment Code</a>‚Äîcheck us out!), this greatly saddens me. This blog series aims to bring back some love for Sequence Parallelism for Inference.</p>
<blockquote>
<p>üíî Another embarrassing reason for this blog series is because I have spent ungodly hours re-inventing Sequence Parallelism variants and begrudgingly realized that many of my so-called original ideas were just from papers I read back in school (many such cases). So I decided to sit down and write to prevent another poor soul (and my future self) from wasting time re-deriving the basics of Sequence Parallelism</p>
</blockquote>
<p>This blog series assumes that model weights can fit on a small number of GPUs within a single node (2 or 4). If you need all 8 GPUs in a node or multi-node deployment just to fit the weights, Sequence Parallelism might not be the sole solution - you may need to use it in conjunction with other parallelism techniques.</p>
<h2 id="notation">Notation</h2>
<ul>
<li>
<p>$N$ is the tensor size</p>
</li>
<li>
<p>$p$ is the number of devices</p>
</li>
<li>
<p>$B$ is batch size</p>
</li>
<li>
<p>$T$ is sequence length</p>
</li>
<li>
<p>$nkv \text{ and } nq$ denote number of kv heads and q heads respectively.</p>
</li>
<li>
<p>$d$ is headdim</p>
</li>
<li>
<p>$H$ is hidden dimension, $H = nq \times d$</p>
</li>
</ul>
<h1 id="what-is-sequence-parallelism-sp">What is Sequence Parallelism (SP)?</h1>
<p>In one sentence: sequence parallelism shards the input along the sequence dimension across devices, and subsequent operations‚Äîsuch as ResidualAdd, LayerNorm, and MatMuls‚Äîare performed on these partitioned sequences. Attention is the only exception, where tokens are dependent (causal) and often require either full KV and/or full Q for computation.
The idea sounds simple enough, but in reality there are <em>many</em> sequence parallelism variants. Before we dive deeper into different SP variants, let&rsquo;s take a quick detour to explain why Tensor Parallelism isn&rsquo;t good enough for low-latency prefill.</p>
<h1 id="why-is-tensor-parallelism-tp-not-good-enough">Why is Tensor Parallelism (TP) not good enough?</h1>
<p>To reduce TTFT, the first thought is to apply a higher degree of TP. During prefill, as we increase TP degree, both attention computation and MLP scale down roughly linearly. However:</p>
<ol>
<li>
<p>LayerNorm computation does not scale with more devices</p>
</li>
<li>
<p>All-Reduce communication volume increases with more devices</p>
</li>
</ol>
<p><strong>For latency-sensitive applications, this is simply not good enough. The solution is, as you&rsquo;ve guessed from the title, Sequence Parallelism (and friends)!</strong></p>
<h1 id="sequence-parallelism-variants">Sequence Parallelism variants</h1>
<p>There are many SP variants. I&rsquo;ve created this semi-opinionated taxonomy to organize them.</p>
<p><img src="/SP_taxonomy.png" alt="SP Taxonomy">
As shown in the taxonomy, we&rsquo;ll focus on Vanilla SP, Megatron-style SP, and Ulysses SP.</p>
<h2 id="vanilla-sequence-parallelism-or-context-parallelism">Vanilla Sequence Parallelism (or Context Parallelism)</h2>
<p><img src="/SP.png" alt="Vanilla Sequence Parallelism">
<strong>Pros</strong>: With Vanilla Sequence Parallelism, MLP and LN scale down roughly linearly with the number of devices since these operations now act on sharded input sequences.
Furthermore, the communication overhead is significantly lower than TP:</p>
<ul>
<li>
<p>We only need 1 All-Gather compared to 2 All-Reduces</p>
</li>
<li>
<p>For Ring All-Gather, the per-device communication volume is $\frac{2 \times (p - 1) \times N }{p}$</p>
</li>
<li>
<p>However, in this case, $N = B \times T \times 2nkv \times d$. For GQA, $2nkv \times d << H = nq \times d$</p>
</li>
</ul>
<p><strong>Cons</strong>: Vanilla Sequence Parallelism introduces attention computation imbalance. The rightmost portion of Q must attend to <em>all</em> of KV, while the leftmost portion of Q only attends to its corresponding leftmost portion of KV. As a result, Attention still scales with more devices but performs slightly worse than TP.
You can use load balancing algorithms to combat the attention imbalance. For strictly causal masks, one notable approach is zig-zag attention.</p>
<div style="display: flex; gap: 20px; justify-content: center;">
  <figure style="flex: 1; text-align: center;">
    <img src="/contiguous_sharding.png" alt="Contiguous sharding" style="max-width: 100%;">
    <figcaption>Contiguous sharding</figcaption>
  </figure>
  <figure style="flex: 1; text-align: center;">
    <img src="/zigzag_sharding.png" alt="Zig-zag sharding" style="max-width: 100%;">
    <figcaption>Zig-zag sharding</figcaption>
  </figure>
</div>
Approaches like this have a couple of pain points: (i) NCCL all-gather expects a contiguous tensor, and (ii) for more generalized masks (especially document masking), the sharding layout becomes quite complex.
<h2 id="megatron-sequence-parallelism">Megatron Sequence Parallelism</h2>
<p><img src="/megatron.png" alt="Megatron Sequence Parallelism">
The high-level idea: perform Attention and MLP blocks in TP, and LayerNorm in SP. In detail:</p>
<ol>
<li>
<p>Shard the input sequence along the sequence dimension</p>
</li>
<li>
<p>Attention LayerNorm acts on the sharded input sequence</p>
</li>
<li>
<p>All-Gather the sharded input sequence into the full sequence</p>
</li>
<li>
<p>Perform the Attention Block (QKV proj, Attention, and O proj) in traditional TP fashion</p>
</li>
<li>
<p>Reduce partial results of O proj and scatter them along the input sequence</p>
</li>
<li>
<p>MLP LayerNorm acts on the sharded input sequence</p>
</li>
<li>
<p>All-Gather the sharded input sequence into the full sequence</p>
</li>
<li>
<p>Perform the MLP Block (expand, activation, and shrink) in traditional TP fashion</p>
</li>
<li>
<p>Reduce partial results of shrink and scatter them along the input sequence for the next layer&rsquo;s Attention LayerNorm</p>
</li>
</ol>
<blockquote>
<p>‚ùì Uhh why would one use this over TP? Isn‚Äôt the point of Megatron-SP is to reduce activation memory overhead during training?</p>
</blockquote>
<p>Yes, but surprisingly this is <em>faster</em> than TP for prefill. While the communication overhead is roughly the same‚ÄîAll-Reduce is equivalent to All-Gather + Reduce-Scatter (relatively true for large message sizes, assuming the same tensor size)‚ÄîLN scales linearly since it acts on sharded input sequences.</p>
<ul>
<li>
<p>Ring All-Gather and Reduce-Scatter both have per-device communication volume of $\frac{(p - 1) \times N}{p}$. In practice, Reduce-Scatter is usually slightly slower than All-Gather.</p>
</li>
<li>
<p>As noted earlier, ring All-Reduce per-device communication volume is $\frac{2 \times (p - 1) \times N}{p}$, which is exactly All-Gather + Reduce-Scatter. In practice, ring All-Reduce for large message sizes is often implemented as a two-phase algorithm: Reduce-Scatter followed by All-Gather.</p>
</li>
</ul>
<p>Since we don&rsquo;t care about reducing activation memory, we can do even better for inference by eliminating one pair of All-Gather + Reduce-Scatter.</p>
<p><img src="/megatron-sp-tp.png" alt="Megatron SP-TP">
Instead of All-Gathering the sharded sequence after MLP-LN, we skip it and perform the MLP block on the sharded sequence. This eliminates a pair of All-Gather + Reduce-Scatter, cutting our communication overhead in half.
<strong>Pros:</strong> MLP, LN, and Attention all scale down ~linearly with the number of devices. Attention is head-parallel (no imbalance), while MLP and LN act on sharded input sequences. The communication overhead is ~1/2 that of TP‚Äîwe only do one All-Gather + Reduce-Scatter compared to two All-Reduces.
<strong>Cons:</strong> Compared to Vanilla SP, Megatron SP has significantly higher communication volume</p>
<ul>
<li>
<p>For the Megatron variant above, we do an All-Gather after Attn LN and a Reduce-Scatter after O proj, both with tensor sizes of $N = B \times T \times H$.</p>
</li>
<li>
<p>Once again, because $nq >> nkv$ for GQA models, per device communication volume of Megatron SP is significantly higher than that of Vanilla SP.</p>
</li>
</ul>
<h2 id="ulysses-sequence-parallelism">Ulysses Sequence Parallelism</h2>
<p><img src="/ulysses.png" alt="Ulysses Sequence Parallelism">
The high-level idea: perform only Attention computation in TP and everything else in SP. In detail:</p>
<ol>
<li>
<p>Shard the input sequence along the sequence dimension</p>
</li>
<li>
<p>Attention LayerNorm acts on the sharded input sequence</p>
</li>
<li>
<p>Pass the sharded input sequence to QKV proj to get sequence-sharded Q, K, V</p>
</li>
<li>
<p>Perform an All-To-All to reshard the sequence-sharded Q, K, V into head-sharded Q, K, V</p>
</li>
<li>
<p>Each device performs attention on a subset of heads</p>
</li>
<li>
<p>Perform an All-To-All to reshard the head-sharded <code>attn_output</code> back to sequence-sharded</p>
</li>
<li>
<p>Pass the sequence-sharded output to O proj, LayerNorm, and MLP block</p>
</li>
</ol>
<p><strong>Pros:</strong> MLP, LN, and Attention all scale linearly with the number of devices since Attention is head-parallel (no imbalance). The communication overhead is significantly smaller than TP‚Äîtwo All-To-Alls during Ulysses SP compared to two All-Reduces during TP.</p>
<ul>
<li>
<p>The per-device All-To-All communication volume is $N$. In practice, the self-data transfer step (where a device sends $\frac{N}{p}$ data to itself) is very fast because it&rsquo;s just a local copy.</p>
</li>
<li>
<p>For Ulysses, we perform an All-To-All after QKV projection where $N = \frac{B \times T \times (nq + nkv) \times d}{p}$ and another All-To-All where $N = \frac{B \times T \times H}{p}$.</p>
</li>
<li>
<p>Notice that per-device communication volume scales down roughly linearly with more devices. At $p = 4$, the ratio between Ulysses SP and TP is $\frac{2nq + nkv}{12nq}$. For GQA where $nkv << nq$, this ratio is <em>much</em> smaller than 1!</p>
</li>
</ul>
<p><strong>Cons:</strong> Ulysses cannot shard the sequence dimension beyond the number of KV heads, which is a deal breaker for MHA models where $nkv = 1$ or for GQA models where $nkv$ is substantially small.
Ulysses has slightly higher communication overhead than Vanilla SP.</p>
<ul>
<li>The per-device communication volume ratio between Ulysses and Vanilla SP is $\frac{2nq + nkv}{8nkv}$. For GQA with small $nq / nkv$, this ratio is only slightly larger than 1!</li>
</ul>
<h2 id="some-closing-notes">Some closing notes</h2>
<p>So far, it&rsquo;s been really fun to see how you can move communication between Transformer ops, switch between different sharding strategies, and shave off communication overhead. The computation and communication nature then change drastically. Notice how in all of these sequence parallelism variants, communication and computation are still done separately, the next post will be about fusing and overlapping them together! Stay tuned.</p>
<h3 id="references">References</h3>
<p><a href="https://arxiv.org/abs/2205.05198">Megatron-SP</a>
<a href="https://arxiv.org/pdf/2507.07120">Helix Parallelism</a>
<a href="https://arxiv.org/abs/2310.01889">Ring Attention</a>
<a href="https://www.snowflake.com/en/engineering-blog/ulysses-low-latency-llm-inference/">Arctic Ulysses</a>
<a href="https://www.snowflake.com/en/engineering-blog/arctic-inference-shift-parallelism/">Shift Parallelism</a>
<a href="https://arxiv.org/pdf/2411.01783v3">Context Parallelism</a></p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://example.org/" >
    &copy;  My New Hugo Site 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
